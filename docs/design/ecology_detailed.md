## 1. 生与死：基于能量与损伤的物理闭环

生命在系统中被定义为一种“负熵”过程，即通过消耗能量来维持物理结构的完整性。

* **生的触发（Reproduction）**：
* **能量阈值**：当 `PhysicalBody` 的 `energy_storage` 超过 `ReproductionStatus.energy_threshold`（例如最大值的 80%）且年龄达标时，触发繁殖动作。
* **物质消耗**：繁殖不是凭空产生的，它会扣除母体大量的能量，并将其转化为后代的初始生命值与物理结构。


* **死的判定（Mortality）**：
* **能量耗尽**：当 `energy_storage <= 0.0` 时，个体无法维持代谢，进入 `Dying` 状态。
* **物理崩溃**：如果 `PhysicalBody` 的 `attributes.health`（健康值）因攻击或环境（如极端温度）降至 0，个体死亡。
* **遗产处理**：死亡后，实体的 `MaterialProperties`（如能量密度、质量）依然存在，它变为一个“资源实体”，可以被其他个体 `Consume`（摄取）。



---

## 2. 遗传与变异：基于向量空间的演化

变异不是预设的进化路线，而是属性在向量空间中的随机漂移。

* **遗传引擎 (Inheritance)**：
* 系统读取父辈的 `Genome` 向量。
* **公式逻辑**：。


* **变异稳定性控制**：
* 变异率 `mutation_rate` 本身也是 `Genome` 的一部分，这意味着“变异本身也会进化”。


* **生殖隔离 (Speciation)**：
* 利用欧氏距离计算两个个体的基因差异：。
* 仅当  时允许交配，这保证了物种的稳定性，防止产生无法生存的“混合混沌”。



---

## 3. 智能：从“硬编码”转向“基因权重驱动”

你目前的 `thinking_system.rs` 使用了硬编码的判断（如 `energy_storage < 0.4`）。要实现智能的进化，必须将这些**判断阈值参数化**。

### **智能的三个实现层级：**

* **感知层 (Sensors)**：
* 个体调用 `Scan` 动作，获取周围实体的属性（硬度、能量密度等）。
* **进化点**：`sensory_range` 基因决定了你能“看”多远。


* **决策层 (Utility AI)**：
* 系统计算每个潜在动作的得分。得分不再由你写死，而是：
* 
* **进化点**：`Genome` 存储了对“饥饿”或“好奇心”的敏感度权重。


* **执行层 (Atomic Actions)**：
* AI 最终输出一个原子动作（如 `Move` 或 `Link`）。
* **个体的“学习”**：通过 `Brain` 中的 `memory` 记录“动作 + 结果 = 效用”。如果在生命周期内，某个个体发现“连接两个物体”能大幅提升能量获取，它会在记忆中强化这一逻辑。



---

## 4. 总结：系统如何协同工作？

| 阶段 | 逻辑描述 | 涉及组件 |
| --- | --- | --- |
| **存在** | 消耗能量维持代谢，根据 `Genome` 表现物理特征。 | `PhysicalBody`, `Genome` |
| **思考** | 根据 `Genome` 赋予的权重，对当前环境进行效用评分，选择动作。 | `Brain`, `Motivation`, `Memory` |
| **演化** | 成功存活并积累能量的个体进行 `Reproduction`，产生带偏移的 `Genome`。 | `ReproductionStatus`, `Generation` |
| **反馈** | 玩家通过 `Sprite.color`（由基因映射）观察不同“颜色”种群的兴衰。 | `Renderable`, `StatusDisplay` |

> **设计心得**：
> 这种设计的巧妙之处在于，你不需要去写“如何变聪明”的代码。你只需要写一个“会根据基因权重乱试动作”的 AI，以及一个“能量不足就会死”的物理系统。
> **聪明**（即高效的动作序列）会作为一种生存策略，在无数次的死亡与繁殖中自动被系统“筛选”出来。

