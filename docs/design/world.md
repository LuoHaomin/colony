## 1. 世界组成：从“分类”转向“属性矩阵”

世界不再由孤立的“物品类型”组成，而是由一套通用的物理和环境属性驱动。

### **Z-Level 三维垂直空间**

* **多层架构**：世界由真正的三维坐标系 `Position { x, y, z }` 构成，支持垂直高度上的地貌起伏与层级切换。
* **空间连通性**：不同层级之间通过物理坡度或未来实现的建筑（如梯子）连接，资源与生物随高度分布。

### **万物属性化 (Universal Properties)**

* **去枚举化**：弱化现有的 `ItemType` 和 `ActorType` 枚举，将实体抽象为属性的集合。
* **物质组件 (`MaterialProperties`)**：
* **硬度 (Hardness)**：决定物体是否能被破坏或作为工具。
* **质量 (Mass)**：影响移动消耗与动能计算。
* **能量密度 (Energy Density)**：决定其作为食物或燃料的价值。


* **功能潜力 (`Affordance`)**：实体不再被标记为“斧头”，而是具有“可传递力”、“可阻挡通行”或“可容纳能量”等潜力。

### **动态环境层 (`EnvironmentalData`)**

* **实时场域**：每个坐标点具有动态的温度、湿度与肥沃度。
* **环境压力**：环境数据直接影响生物的能量消耗率（如极端温度导致代谢加快）以及植物的生长效率。

---

## 2. 交互逻辑：物理公理与原子动作

交互不再是执行预设的“脚本”，而是基于底层物理规则的即时反馈。

### **原子化动作 (Atomic Actions)**

* **行为解耦**：AI 并不执行“砍伐”或“采集”这种高级任务，而是发出原子指令：
* **`ApplyForce` (施加力)**：根据工具硬度与目标硬度决定结果。
* **`Consume` (消耗)**：提取目标的能量密度值。
* **`Link` (连接)**：将两个实体组合，形成复合实体。



### **复合实体的涌现 (Composite Entities)**

* **属性叠加**：当生物执行 `Link` 动作（如将树枝与石头结合）时，系统自动计算父子级实体的总质量。
* **性能计算**：工具的效能由物理公式自动得出。
* 例如：。


* 这种逻辑允许玩家和 AI 在没有预设“合成表”的情况下，通过物理组合发明出工具。

### **效用反馈闭环**

* **动作结果评估**：系统不告诉 AI 动作是否正确，而是由 `ThinkingSystem` 观察动作后需求的满足情况。
* **效用映射**：如果 `Link(A, B)` 后执行 `ApplyForce` 获得了更多能量，该动作序列在 `Brain` 记忆中的权重就会提升。

### 一、 物体属性模拟：从“身份”到“物质特征”

无论是生物还是非生物，在系统底层都应被视为具有不同物理权重的“实体”。

#### 1. 非生物属性（物理与材质基础）

这决定了物体在物理世界中的表现，以及它们被生物利用的潜力：

* **质量 (Mass)**：影响移动物体的能量消耗，以及在碰撞/打击动作中产生的动能。
* **硬度 (Hardness)**：决定物体抵抗形变的能力。它是判断“谁砍得动谁”的核心标准。
* **韧性 (Toughness/Integrity)**：决定物体在受到超过硬度限度的力时，是产生“碎片化（资源掉落）”还是直接消失。
* **能量密度 (Energy Density)**：物体蕴含的潜在化学能。高密度的被视为“食物”，中密度的可能作为“燃料”。
* **传导性 (Conductivity)**：对热量、电荷或水分的传导效率，直接影响 Z-Level 的环境模拟（如房屋保温）。
* **几何特征 (Geometry Affordance)**：标记物体的物理形状（如“锋利度”、“平整度”、“容纳空间”），决定它能触发哪些效用公式。

#### 2. 生物属性（表现型基因表达）

生物的属性是其 `Genome`（基因组）在当前环境下的翻译结果：

* **基础代谢率 (Metabolic Rate)**：单位时间内维持生命所需的最低能量。进化出的体型越大、大脑越复杂，该值越高。
* **肢体强度 (Limb Strength)**：决定生物能施加的 `ApplyForce`（作用力）的最大值。
* **感官敏锐度 (Sensory Acuity)**：包括视野（Visual Range）、嗅觉或听觉的阈值，决定其能感知到的实体信息范围。
* **神经复杂度 (Neural Capacity)**：决定生物 `Brain` 组件的层级（反射层/动机层/认知层），即它能处理多少记忆序列或复杂的效用评估。
* **环境耐受度 (Environmental Tolerance)**：对温度、湿度波动的抵抗范围。

---

### 二、 生物动作类型：原子化的行为指令

为了支持高自由度的进化，生物不应执行“砍树”这种复合任务，而应执行以下**原子动作**：

#### 1. 物理操纵类（Physical Manipulation）

* **移动 (Move)**：改变自身在三维坐标系 `Position` 中的位置。
* **施力 (ApplyForce)**：对目标实体施加矢量力。根据工具硬度和动作目标，它在逻辑上表现为“打击”、“推动”或“挖掘”。
* **连接/抓取 (Link/Grasp)**：将自身与物体或两个物体之间建立父子级关联。这是“装备工具”和“建造建筑”的底层基础。
* **解除连接 (Unlink/Release)**：放下物体或拆解复合实体。

#### 2. 代谢与生存类（Biological Maintenance）

* **摄取 (Ingest/Consume)**：尝试吸收目标的能量。成功与否取决于生物的 `diet_type`（饮食类型基因）与目标的能量属性是否匹配。
* **静息 (Rest/Process)**：降低代谢，同时将短期记忆转化为长期权重。
* **繁殖 (Reproduce)**：当能量和年龄达到 `ReproductionStatus` 设定的阈值时，生成后代并进行基因漂移。

#### 3. 信息与认知类（Cognitive Actions）

* **扫描 (Scan/Observe)**：获取视野内实体的属性（硬度、能量等）。这是 AI 进行效用评估的前提。
* **信号 (Signal)**：发出简单的物理波动（声音/颜色改变），用于高社交性生物之间的信息传递或威胁恐吓。

---

### 三、 属性与动作的交互：如何“涌现”出复杂性？

在这套细化的属性系统下，游戏行为是如何在没有预设的情况下发生的？

1. **“砍伐”的涌现**：
* **基因**：一个个体具有高“肌肉强度”基因。
* **动作**：它随机执行了 `ApplyForce`。
* **判定**：系统计算 `(生物力 + 工具硬度) > 树木韧性`。
* **结果**：树木实体产生 `Dying` 状态并掉落具有 `Mass` 的木材。


2. **“建造”的涌现**：
* **需求**：环境温度低于耐受度，`energy_storage` 下降过快。
* **动作**：生物执行 `Move` 和 `Link`，将多个具有 `Hardness` 的物体堆叠在自身周围。
* **判定**：物理系统检测到周围形成封闭面，局部 `EnvironmentalData` 发生改变。
* **强化**：`Brain` 记录下“堆叠物体 = 能量消耗减缓”的记忆权重，导致该行为在种群中固化。



这种细化方案将原本繁琐的 `Task` 逻辑（如 `Task::Chop`）完全拆解为**属性间的物理运算**。这不仅能解决代码历史遗留的分类冲突，还能让你的“进化自由度”在数学层面得到支撑。


在 **Colony** 的设计中，生与死、遗传变异与智能是构成“进化型物理仿真”闭环的核心。基于你现有的代码架构，我们可以将这些复杂的生命现象拆解为以下可编程的逻辑：

---

## 1. 生与死：基于能量与损伤的物理闭环

生命在系统中被定义为一种“负熵”过程，即通过消耗能量来维持物理结构的完整性。

* **生的触发（Reproduction）**：
* **能量阈值**：当 `PhysicalBody` 的 `energy_storage` 超过 `ReproductionStatus.energy_threshold`（例如最大值的 80%）且年龄达标时，触发繁殖动作。
* **物质消耗**：繁殖不是凭空产生的，它会扣除母体大量的能量，并将其转化为后代的初始生命值与物理结构。


* **死的判定（Mortality）**：
* **能量耗尽**：当 `energy_storage <= 0.0` 时，个体无法维持代谢，进入 `Dying` 状态。
* **物理崩溃**：如果 `PhysicalBody` 的 `attributes.health`（健康值）因攻击或环境（如极端温度）降至 0，个体死亡。
* **遗产处理**：死亡后，实体的 `MaterialProperties`（如能量密度、质量）依然存在，它变为一个“资源实体”，可以被其他个体 `Consume`（摄取）。



---

## 2. 遗传与变异：基于向量空间的演化

变异不是预设的进化路线，而是属性在向量空间中的随机漂移。

* **遗传引擎 (Inheritance)**：
* 系统读取父辈的 `Genome` 向量。
* **公式逻辑**：。


* **变异稳定性控制**：
* 变异率 `mutation_rate` 本身也是 `Genome` 的一部分，这意味着“变异本身也会进化”。


* **生殖隔离 (Speciation)**：
* 利用欧氏距离计算两个个体的基因差异：。
* 仅当  时允许交配，这保证了物种的稳定性，防止产生无法生存的“混合混沌”。



---

## 3. 智能：从“硬编码”转向“基因权重驱动”

你目前的 `thinking_system.rs` 使用了硬编码的判断（如 `energy_storage < 0.4`）。要实现智能的进化，必须将这些**判断阈值参数化**。

### **智能的三个实现层级：**

* **感知层 (Sensors)**：
* 个体调用 `Scan` 动作，获取周围实体的属性（硬度、能量密度等）。
* **进化点**：`sensory_range` 基因决定了你能“看”多远。


* **决策层 (Utility AI)**：
* 系统计算每个潜在动作的得分。得分不再由你写死，而是：
* 
* **进化点**：`Genome` 存储了对“饥饿”或“好奇心”的敏感度权重。


* **执行层 (Atomic Actions)**：
* AI 最终输出一个原子动作（如 `Move` 或 `Link`）。
* **个体的“学习”**：通过 `Brain` 中的 `memory` 记录“动作 + 结果 = 效用”。如果在生命周期内，某个个体发现“连接两个物体”能大幅提升能量获取，它会在记忆中强化这一逻辑。



---

## 4. 总结：系统如何协同工作？

| 阶段 | 逻辑描述 | 涉及组件 |
| --- | --- | --- |
| **存在** | 消耗能量维持代谢，根据 `Genome` 表现物理特征。 | `PhysicalBody`, `Genome` |
| **思考** | 根据 `Genome` 赋予的权重，对当前环境进行效用评分，选择动作。 | `Brain`, `Motivation`, `Memory` |
| **演化** | 成功存活并积累能量的个体进行 `Reproduction`，产生带偏移的 `Genome`。 | `ReproductionStatus`, `Generation` |
| **反馈** | 玩家通过 `Sprite.color`（由基因映射）观察不同“颜色”种群的兴衰。 | `Renderable`, `StatusDisplay` |

> **设计心得**：
> 这种设计的巧妙之处在于，你不需要去写“如何变聪明”的代码。你只需要写一个“会根据基因权重乱试动作”的 AI，以及一个“能量不足就会死”的物理系统。
> **聪明**（即高效的动作序列）会作为一种生存策略，在无数次的死亡与繁殖中自动被系统“筛选”出来。

